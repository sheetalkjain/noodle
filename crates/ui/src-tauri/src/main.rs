use agent::engine::SyncManager;
use agent::pipeline::ExtractionPipeline;
use ai::provider::{AiProvider, LocalProvider};
use outlook::client::OutlookClient;
use std::sync::Arc;
use storage::qdrant::QdrantStorage;
use storage::sqlite::SqliteStorage;
use tauri::{command, Manager, State};
use tracing::info;

struct AppState {
    sqlite: Arc<SqliteStorage>,
    qdrant: Arc<QdrantStorage>,
    ai: Arc<dyn AiProvider>,
    pipeline: Arc<ExtractionPipeline>,
    outlook: Arc<OutlookClient>,
}

#[command]
async fn search_emails(
    state: State<'_, AppState>,
    query: String,
) -> Result<Vec<serde_json::Value>, String> {
    // 1. Generate embedding for query
    let embedding = state
        .ai
        .generate_embedding(&query)
        .await
        .map_err(|e| e.to_string())?;

    // 2. Vector Search in Qdrant
    let results = state
        .qdrant
        .search_emails(embedding, None, 20)
        .await
        .map_err(|e| e.to_string())?;

    // 3. Fetch full email data from SQLite using internal IDs
    let ids: Vec<i64> = results
        .into_iter()
        .filter_map(|r| {
            r.id.and_then(|id| id.point_id_options)
                .and_then(|id| match id {
                    qdrant_client::qdrant::point_id::PointIdOptions::Num(num) => Some(num as i64),
                    _ => None,
                })
        })
        .collect();

    state
        .sqlite
        .get_emails_by_ids(ids)
        .await
        .map_err(|e| e.to_string())
}

#[command]
async fn get_graph(state: State<'_, AppState>) -> Result<serde_json::Value, String> {
    state.sqlite.get_entities().await.map_err(|e| e.to_string())
}

#[command]
async fn get_stats(state: State<'_, AppState>) -> Result<serde_json::Value, String> {
    state
        .sqlite
        .get_dashboard_stats()
        .await
        .map_err(|e| e.to_string())
}

#[command]
async fn start_sync(state: State<'_, AppState>) -> Result<(), String> {
    let sync_manager = Arc::new(SyncManager::new(
        state.pipeline.clone(),
        state.outlook.clone(),
        state.sqlite.clone(),
    ));

    tokio::spawn(async move {
        sync_manager.start_background_sync().await;
    });

    Ok(())
}

#[command]
async fn get_email(_state: State<'_, AppState>, _id: i64) -> Result<serde_json::Value, String> {
    Ok(serde_json::json!({}))
}

#[command]
async fn list_prompts(_state: State<'_, AppState>) -> Result<Vec<serde_json::Value>, String> {
    Ok(vec![])
}

#[command]
async fn save_prompt(
    _state: State<'_, AppState>,
    _prompt: serde_json::Value,
) -> Result<(), String> {
    Ok(())
}

#[command]
async fn draft_reply(_state: State<'_, AppState>, _email_id: i64) -> Result<String, String> {
    Ok("Draft reply generated by Noodle AI...".into())
}

fn main() {
    tauri::Builder::default()
        .setup(|app| {
            let app_handle = app.handle().clone();

            tauri::async_runtime::block_on(async move {
                let app_dir = app_handle.path().app_data_dir().unwrap();
                std::fs::create_dir_all(&app_dir).unwrap();

                let db_path = app_dir.join("noodle.db");
                let sqlite = Arc::new(SqliteStorage::new(db_path).await.unwrap());

                // Qdrant initialization usually needs a URL or host in v2-rc
                let qdrant = Arc::new(QdrantStorage::new("http://localhost:6334").await.unwrap());

                // Initialize AI with a local endpoint (e.g. LM Studio or Localhost shim)
                let ai: Arc<dyn AiProvider> =
                    Arc::new(LocalProvider::new("http://localhost:1234/v1".into(), None));

                let pipeline = Arc::new(ExtractionPipeline::new(
                    sqlite.clone(),
                    qdrant.clone(),
                    ai.clone(),
                ));

                let outlook = Arc::new(OutlookClient::new().unwrap());

                app_handle.manage(AppState {
                    sqlite,
                    qdrant,
                    ai,
                    pipeline,
                    outlook,
                });
            });

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            search_emails,
            get_stats,
            get_graph,
            start_sync,
            get_email,
            list_prompts,
            save_prompt,
            draft_reply
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
